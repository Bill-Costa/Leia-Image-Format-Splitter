#!/usr/bin/env perl
# -*- cperl -*-
#
#         File:	mij-splitter
#      Summary:	Splits a Multi-Image Jpeg image file into separate files.
#        Usage:	mij-splitter file1 [...]
#	  Help:	mij-splitter -h
#     Man Page:	mij-splitter -m
#       Author:	Bill.Costa@alumni.unh.edu
#      Version: v1.0-20220316
# Project Page:	https://github.com/Bill-Costa/Multi-Image-JPEG-Splitter
#
#      THIS SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND,
#      EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
#      OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
#      NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
#      HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
#      WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
#      FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
#      OTHER DEALINGS IN THE SOFTWARE.
#
#
#=============================================================================

use warnings;			# Warning me when I do something stupid.
use strict;			# Keep things squeaky clean.
use Data::Dumper;		# Easy data structure debugging.
   $Data::Dumper::Terse = 1;	# Suppress the "$VAR1" string; limit padding.
use Getopt::Long;		# Parse our command line please.
use File::Basename;		# For parsing file names.
use File::Spec::Functions;	# For building file specs portably.
use Pod::Usage;			# Easy usage text, help, and man page.
#use Text::Abbrev;		# Allow keyword abbreviation.
use Fcntl qw(SEEK_SET);         # Used in seek() function for moving cursor.
no autovivification;		# Allow hash key testing without auto creation.
				#--[ Global Vars ]-----------------------------
my $ownName = (fileparse	# Get our own name, that is, how we were
                (		#   invoked, minus pathname and suffix.
		  $0,
		  qr/\.[^.]*/
		)
              )[0];

my $discardBuf    = undef();	# If defined, non-image binary data
my %opt           = ();		# Command line options.
$opt{allMode}     = undef();	# -all     : export all JPGs with ord naming
$opt{clobberMode} = 0;		# -clobber : overwrite existing file
$opt{debugMode}   = undef();	# -debug   : undef or 0-9
$opt{extraMode}   = 0;		# -extra   : non-image data to _extra file
$opt{forceMode}   = 0;          # -force   : ignore file size limit; extension
$opt{outputDir}   = undef();	# -output  : where to write our output files
$opt{quietMode}   = 0;		# -quiet   : suppress warning messages
$opt{verboseMode} = 0;		# -verbose : show progress
#$opt{whatIfMode}  = 0;		# -whatif  : echo action but change nothing

my $FF = chr(0xFF);
my $D8 = chr(0xD8);
my $D9 = chr(0xD9);
my $MAX_SIZE = (4 * 8000 * 5000); # 4 uncompressed 8K images in one file.
my $EXPECT_FILE_TYPE_RE   = qr/\.(jpg|mpo)$/i;
my $EXCLUDE_OUR_OUTPUT_RE = qr/_(L|R).(jpg)$/i;
my $EXCLUDE_SINGLE_3D_RE  = qr/.(jps)$/i;

#==============================================================================
#  Subroutines  ===============================================================
#==============================================================================

sub isMissing ( $ )

#      Abstract: Returns true if scalar is undefined, empty, or blank string.
#
#    Parameters: $str -- simple char string or undefined
#
#       Returns: $bool -- true if there is no useful value
#
#  Precondition: None.
#
# Postcondition: Returns boolean value with no side effects.

{
  if (not defined($_[0]) or $_[0] =~ m/^\s*$/s) { return(1) }
  else                                          { return(0) }
}

#------------------------------------------------------------------------------

sub trimStr ( $ )

#      Abstract: Remove leading and trailing whitespace.
#
#    Parameters: $str -- simple char string (no embedded carriage control)
#
#       Returns: $new -- the trimmed string value
#
#  Precondition: None.
#
# Postcondition: $str is returned with  leading and trailing blanks
#		 removed.  If the string is all whitespace, or undefined,
#		 we return an empty string.

{
  my $str = shift(@_);
  return('') if (not defined($str));
  $str =~ s/^\s+|\s+$//g;
  return($str);
}

#------------------------------------------------------------------------------

sub commify ( $ )

#      Abstract: Add American style thousands separator to number.
#
#    Parameters: $num -- number(s) to be edited
#
#       Returns: $str -- formatted text
#
#  Precondition: $num is a defined scalar value.
#
# Postcondition: $str is printable text.
#
#     Reference: https://www.oreilly.com/library/view/perl-cookbook/1565922433/ch02s18.html

{
  my $num = reverse(shift(@_));
  $num =~ s/(\d\d\d)(?=\d)(?!\d*\.)/$1,/g;
  return(scalar(reverse($num)));
}

#------------------------------------------------------------------------------

sub kBytes ( $ )

#      Abstract: Return byte count as human friendly string.
#
#    Parameters: $bytes -- integer value
#
#       Returns: $str   -- formatted text
#
#  Precondition: $bytes is defined and numeric
#
# Postcondition: $str is printable text.

{
  my $bytes = shift(@_);
  return('(internal error; missing)')     if (not defined($bytes));
  return('(internal error; not a count)') if (not $bytes =~ m/^\d+$/);
  return("$bytes bytes")                  if ($bytes < 1000);
  $bytes = commify(int($bytes/1000));
  return($bytes . 'k bytes');
}

#------------------------------------------------------------------------------

sub assert ( $ @ )

#      Abstract: Throws fatal error if $boolExp is not true.
#
#    Parameters: $boolExp   -- a Perl expression to eval as Perlish T/F.
#                $msgStr(s) -- one or more message strings to display on exit.
#
#       Returns: 1 (true) assuming we do not thrown a fatal error
#
#  Precondition: None.
#
# Postcondition: If the expression evaluates to a Perlish false value,
#		 we throw a 'logic error' exception and display any
#		 message strings provided and a stack trace.

{
  use Carp;			# Gives us confess() for stack back-trace,
  $Carp::CarpLevel = 1;	# but don't report the assert() in back-trace.
  my $boolExp = shift(@_);
  $_[0] = '(no message)' if (not defined($_[0]));
  if (not $boolExp)
    {
      $! = 255;
      confess(
	       "! $ownName: internal logic error\n",
	       "_ ", join("\n_ ", @_), "\n_"
	     );
    }

  return(1);
}

#------------------------------------------------------------------------------

sub tellUser ( $ @ )

#      Abstract: Conditionally print diagnostic to STDERR.
#
#    Parameters: $msgLevel  - message type indicator (see below)
#		 $msgStr(s) - one or more message strings to display
#
#       Returns: 1 (true) assuming we don't throw an exception
#
#  Precondition: msgLevel is a single letter, one of [IWU], or the
#		 letter 'D' or 'F' and a single digit (i.e. 'D1',
#		 'F7', etc.).  The remaining parameters, of which
#		 there should be at least one, are treated as message
#		 strings.  The globals $ownName and %flag variables
#		 must be defined.
#
# Postcondition: Print formatted messages to STDERR.  The following
#		 actions are taken depending upon the initial letter
#		 code:
#
#		  'W'  - print a warning unless -quiet is set.
#
#		  'U'  - print fatal error message, usage info, and abort.
#
#		  'I'  - print an info msg if -verbose is set.
#
#                 'T'  - print 'WOULD HAVE:' message if -whatif is set.
#
#		  'Fn' - print a fatal error message and abort
#		         program, where 'n' is an integer > 2, the
#		         exit value.  If not specified, the default
#		         exit value is 3.
#
#		  'Dn' - print debug message if 'n' is less than or
#			 equal to the current debug level value.
#			 (Use 'D0' to always print message, regardless
#			 of user selected debugging level.)

{
  my($level) = uc(shift(@_));

  assert(defined($level), 'required parameter not defined');
  assert(($level =~ m/^[DIWUF]/), "did not expect '$level'");
  assert(scalar(@_) > 0, "no message supplied");

  if ($level =~ m/^D(\d)$/)
    {
      print(STDERR "DDT: ", join("\n   : ", @_), "\n")
	if (defined($opt{debugMode}) and $1 <= $opt{debugMode});
    }
  elsif ($level eq 'I')
    {
      print(STDERR "(i) ", join("\n    ", @_), "\n")
	if ($opt{verboseMode});
    }
  elsif ($level eq 'W')
    {
      warn("? $ownName: ",join("\n_ ", @_),"\n")
        if (not $opt{quietMode});
    }
  elsif ($level eq 'T')
    {
      warn("WOULD-HAVE: ", join("\n          : ", @_),"\n")
        if ($opt{whatIfMode});
    }
  elsif ($level eq 'U')
    {
      my $msg = "? $ownName: " . join("\n_ ", @_);
      pod2usage(-verbose => 0, -exitval => 3, -msg => $msg);
    }
  elsif ($level =~ m/^F([0-9]?[0-9]*)$/)
    {
      if ($1 eq ''  or ($1 <= 3)) { $! = 3  }
      else                        { $! = $1 }

      die("! $ownName: ", join("\n_ ", @_), "\n");
    }
  else
    {
      assert(0, "unreachable code reached; \$level = '$level'");
    }

  return(1);
}

#------------------------------------------------------------------------------

sub processOptions ( )

#      Abstract: Validate and remove options from @ARGV.
#
#    Parameters: None.
#
#       Returns: 1 (true) assuming we don't thrown an exception
#
#  Precondition: We get first crack at the contents of @ARGV.
#
# Postcondition: All flags are found on the command line, assigned to
#		 global variables, and removed from the @ARGV array,
#		 leaving only parameters (if any).

{
  my $helpMode;
  my $manMode;
  # my @SAVE_KW       = qw(pairs jps sbs); # -save option keywords
  # my %SAVE_KW_MATCH = abbrev(@SAVE_KW);  # Recognized abbreviations for all.

  GetOptions(
	      'd|debug:i'  => \$opt{debugMode},
              'a|all!'     => \$opt{allMode},
              'c|clobber'  => \$opt{clobberMode},
              'e|extra'    => \$opt{extraMode},
              'f|force'    => \$opt{forceMode},
              'o|output=s' => \$opt{outputDir},
              'q|quiet!'   => \$opt{quietMode},
              'v|verbose!' => \$opt{verboseMode},
#             'w|whatif'   => \$opt{whatIfMode},

              'h|help'     => \$helpMode,
              'm|manpage'  => \$manMode,
            )
    or pod2usage(-verbose => 0, -exitval => 2);

  #---------------------------------------------+
  # Handle requests for help and exit here.	|
  #---------------------------------------------+

  pod2usage(-noperldoc => 1, -verbose => 1) if ($helpMode);
  pod2usage(                 -verbose => 2) if ($manMode);

  #---------------------------------------------+
  # Check for conflicting options. Exit now	|
  # if we find any.				|
  #---------------------------------------------+

  pod2usage("-verbose and -quiet are mutually exclusive")
    if ($opt{verboseMode} and $opt{quietMode});

  pod2usage("-quiet and -debug are mutually exclusive")
    if ($opt{quietMode} and $opt{debugMode});

  #---------------------------------------------+
  # Get output directory or set a reasonable	|
  # default.					|
  #---------------------------------------------+

  my $sinkDir = $opt{outputDir};
  $sinkDir = File::Spec->curdir() if (isMissing($sinkDir));

  if (-e $sinkDir)
    {
      tellUser('U', 'not a directory', $sinkDir) if (not -d $sinkDir);
    }
  elsif (not mkdir($sinkDir))
    {
      tellUser('F', 'error creating destination directory', $sinkDir, $!);
    }
  else
    {
      tellUser('D3', 'created new destination directory', $sinkDir);
    }

  $opt{outputDir} = $sinkDir;

  #---------------------------------------------+
  # Get the debug mode and show our option	|
  # settings if level 2 or higher.		|
  #---------------------------------------------+

  if (not defined($opt{debugMode})) { $opt{debugMode} = 0 }
  elsif ($opt{debugMode} == 0)      { $opt{debugMode} = 1 }

  tellUser('U', "-debug requires a value from 1-9, not '$opt{debugMode}'")
    if ($opt{debugMode} < 0 or $opt{debugMode} > 9);

  if ($opt{debugMode} >= 2)
    {
      my @buff = ();
      foreach my $key (sort(keys(%opt)))
        {
          my $label = $key;
          $label =~ s/Mode$//;
          $label = '-' . $label;

          my $val = $opt{$key};
          if (not defined($val))   { $val = 'NULL'   }
          elsif ($val !~ m/^\d+$/) { $val = "'$val'" }

          push(@buff, sprintf("%10s = %s", $label, $val));
        }

      tellUser('D2', @buff);
    }

  return(1);
}

#------------------------------------------------------------------------------

sub processParams ( )

#      Abstract: Validate and remove parameters from @ARGV.
#
#    Parameters: None.
#
#       Returns: @files -- an array of one or more filespecs
#
#  Precondition: Local processOptions() is called first.
#
# Postcondition: Removes all remaining parameters from ARGV.  All
#		 files identified in @files are validated or we return
#		 a usage error and throw an exception.


{
  tellUser('U', "one or more filenames expected") if (scalar(@ARGV) < 1);

  my @files   = ();
  my $errCnt  = 0;
  my $ERR_LIM = 5;
  my $argNum  = 1;
  my $argCnt  = scalar(@ARGV);

  foreach my $fSpec (@ARGV)
    {
      last if ($errCnt > $ERR_LIM);		# Limit amount of nagging.

      tellUser('D1', "ARG $argNum of $argCnt: $fSpec");
      $argNum++;
      next if (isMissing($fSpec));

      if (not -e $fSpec)
        {
          tellUser("file lookup error", $fSpec, $!);
          $errCnt++;
          next;;
        }

      if (-d $fSpec)
        {
          tellUser("expect image file, not a directory", $fSpec);
          $errCnt++;
          next;
        }

      my $fSize = (-s $fSpec);
      if ($fSize > $MAX_SIZE and not $opt{forceMode})
        {
          tellUser('W',"suspicious input file size",$fSpec,kBytes($fSize));
          $errCnt++;
          next;
        }

      if (not $opt{allMode})
        {
          if ($fSpec =~ m/$EXCLUDE_SINGLE_3D_RE/)
            {
              tellUser('W', "cannot split composite 3D images ($1)", $fSpec);
              $errCnt++;
              next;
            }

          if (not $fSpec =~ m/$EXPECT_FILE_TYPE_RE/)
            {
              tellUser('W',"expect '.jpg' or '.mpo' file type", $fSpec);
              $errCnt++;
              next;
            }

          if ($fSpec =~ m/$EXCLUDE_OUR_OUTPUT_RE/)
            {
              tellUser('W', "looks like our own output", $fSpec);
              $errCnt++;
              next;
            }
        }

      push(@files, $fSpec);
    }

  tellUser('F', "halting; no files processed") if ($errCnt > 0);
  tellUser('U', "no actionable input")         if (scalar(@files) < 1);

  return(@files);
}

#------------------------------------------------------------------------------

sub isJPEG ( $ $ )

#      Abstract: Returns true if file starts with JPEG image marker.
#
#    Parameters: $fSpec -- the filespec of the source file
#		 $fh -- an open file handle in raw read mode.
#
#       Returns: $bool -- explicitly 0 or 1
#
#  Precondition: $fSpec is the file path and name for the file
#		 attached to $fh; $fh itself is an open file handle in
#		 raw mode and ready for read operations.
#
# Postcondition: The file handle is returned with the cursor set to the
#		 beginning of the file, without regard to its original
#		 position.  A fatal error is thrown if any file
#		 handling error occurs.
#
#         Notes: We make sure we are at the start of the file, sample
#		 the first two characters, rewind back to the start of
#		 the file, return the results of our lookahead.

{
  my($fSpec, $fh) = @_;
  assert((not isMissing($fSpec)), 'required parameter $fSpec is missing');
  assert((not isMissing($fh)),    'required parameter $fh is missing');

  seek($fh, 0, SEEK_SET) or tellUser('F', 'file read error', $fSpec, $!);
  my $charCnt = read($fh, my $str, 2);
  tellUser('F', "file read error", $fSpec, $!) if (not defined($charCnt));
  seek($fh, 0, SEEK_SET) or tellUser('F', "file rewind error", $!);
  return(0) if ($charCnt < 2);
  return(0) if (substr($str,0,1) ne $FF and substr($str,1,1) ne $D8);
  return(1);
}

#------------------------------------------------------------------------------

sub FSM ( $ $ $ )

#      Abstract: Parse byte stream using Finite State Machine model.
#
#    Parameters: $fh      -- an open file handle in raw read mode
#                $fSpec   -- input filename for error reporting
#		 $sinkDir -- where to write output files
#
#       Returns: @segDefs -- set of one or more file segment definitions
#
#  Precondition: $fh is an open file handle in raw mode and ready for
#		 read operations.  It is up to the caller to make sure
#		 we are not handed a file with an inappropriate data
#		 structure or pathologically large file size.
#		 $sinkDir is a valid filepath for an existing
#		 directory where the current process has the ability
#		 to create one or more new files.  Global %opt has
#		 been initialized.
#
# Postcondition: The $fh read pointer is returned with the cursor set
#		 to the beginning of the file.  If there are no
#		 parsing errors, a set of one or more temporary files
#		 are created and information about those files is
#		 reported in an array of segment description hash
#		 records.  In particular, each record looks like the
#		 following:
#
#                  {
#                    tmpSpec => 'mij-splitter_00.img.tmp',
#                       type => 'jpg', # one of 'jpg' or 'bin')
#                  }
#
#     Algorithm: Parsing is done using the Finite State Machine (FSM)
#                model shown below.  To read the table, find the
#                current state on top; read down to find which
#                condition matches the current input character.  For
#                example "IN: ! D8" means if the current input
#                character is *not* the 0xD8 character.  If the input
#                matches the condition, perform the action and read to
#                the right for the next state.
#
#                Q1 is the unique initial starting state.  Q1 and Q5
#                are the only expected halting states.  In particular
#                end of data while in Q3 or Q4 is an error (truncated
#                image).
#
#  +----------+------------+----------+----------+----------+----------+----------+
#  | Q1       | Q2         | Q3       | Q4       | Q5       | Q6       | Q7       |
#  | not      | start      | in       | leave    | end      | in       | leave    |
#  | image    | image      | image    | image    | image    | thumb    | thumb    |
#  ================================================================================
#  | IN: ! FF | IN: ! D8   |          |          | IN: ! FF |          |          |
#  | - echo   | - echo FF  |          |          | - echo   |          |          | Q1
#  |          | - echo     |          |          |          |          |          | not
#  |          |            |          |          |          |          |          | image
#  +----------+------------+----------+----------+----------+----------+----------+
#  | IN: FF   |            |          |          | IN: FF   |          |          |
#  |          |            |          |          |          |          |          | Q2
#  |          |            |          |          |          |          |          | start
#  |          |            |          |          |          |          |          | image
#  +----------+------------+----------+----------+----------+----------+----------+
#  |          | IN: DB     | IN: ! FF | IN: other|          |          | IN: D9   |
#  |          | - new file | - save   | - save   |          |          | - save   | Q3
#  |          | - save FF  |          |          |          |          |          | in
#  |          | - save     |          |          |          |          |          | image
#  +----------+------------+----------+----------+----------+----------+----------+
#  |          |            | IN: FF   |          |          |          |          |
#  |          |            | - save   |          |          |          |          | Q4
#  |          |            |          |          |          |          |          | leave
#  |          |            |          |          |          |          |          | image
#  +----------+------------+----------+----------+----------+----------+----------+
#  |          |            |          | IN: D9   |          |          |          |
#  |          |            |          | - save   |          |          |          | Q5
#  |          |            |          | - close  |          |          |          | end
#  |          |            |          |   file   |          |          |          | image
#  +----------+------------+----------+----------+----------+----------+----------+
#  |          |            |          | IN: D8   |          | IN: other| IN: other|
#  |          |            |          | - save   |          | - save   | - save   | Q6
#  |          |            |          |          |          |          |          | in
#  |          |            |          |          |          |          |          | thumb
#  +----------+------------+----------+----------+----------+----------+----------+
#  |          |            |          |          |          | IN: FF   |          |
#  |          |            |          |          |          | - save   |          | Q7
#  |          |            |          |          |          |          |          | leave
#  |          |            |          |          |          |          |          | thumb
#  +----------+------------+----------+----------+----------+----------+----------+

{
  my($fh, $fSpec, $sinkDir) = @_;
  assert(defined($fh),              'missing required $fh parameter');
  assert((not isMissing($sinkDir)), 'missing required $sinkDir parameter');

  my $sinkRoot  = catfile($sinkDir, $ownName);

  #-------------------------------------+
  # Setup output for the non-image data	|
  # seen.				|
  #-------------------------------------+

  my $extraSpec;
  my $extraFH;
  my $extraCnt = 0;

  if ($opt{extraMode})
       { $extraSpec = catfile($sinkDir, "${ownName}_extra.tmp") }
  else { $extraSpec = File::Spec->devnull()                     }

  open($extraFH, '>:raw', $extraSpec)
    or tellUser('F', 'error opening temp output file', $extraSpec, $!);

  #-------------------------------------+
  # Ready our input for char-by-char	|
  # reading from first byte.		|
  #-------------------------------------+

  my @segDefs  = ();
  my $nxtState = 'Q1';
  my $imgCnt   = 0;
  my $chrCnt   = 0;
  my $tmpSpec  = catfile($sinkDir, "${ownName}_$imgCnt.tmp");
  my $imgFH;

  seek($fh, 0, SEEK_SET) or tellUser('F', 'file read error', $fSpec, $!);
  local $/ = undef; # Do not break input into records.

  tellUser('D1', "   parsing: $fSpec");
  while (read($fh, my $c, 1))
    {
      $chrCnt++;
      if ($nxtState eq 'Q1')
        {
          if ($c eq $FF) { $nxtState = 'Q2'                }
          else           { print($extraFH $c); $extraCnt++ }
        }
      elsif ($nxtState eq 'Q2')
        {
          if ($c ne $D8)
            {
              print($extraFH $FF, $c);
              $extraCnt += 2;
              $nxtState = 'Q1';
            }
          else # complete SOI marker found, start saving next image
            {
              print($extraFH "<IMG$imgCnt>");
              $tmpSpec = catfile($sinkDir, "${ownName}_$imgCnt.tmp");
              open($imgFH, '>:raw', $tmpSpec)
                or tellUser('F', 'temp image file create error', $tmpSpec, $!);

              print($imgFH $FF, $c);
              tellUser('D1', "writing to: $tmpSpec");
              $nxtState = 'Q3';
              $imgCnt++;
            }
        }
      elsif ($nxtState eq 'Q3')
        {
          print($imgFH $c);
          $nxtState = 'Q4' if ($c eq $FF);
        }
      elsif ($nxtState eq 'Q4')
        {
          print($imgFH $c);
          if    ($c eq $D9) { $nxtState = 'Q5' }
          elsif ($c eq $D8) { $nxtState = 'Q6' }
          else              { $nxtState = 'Q3' }
        }
      elsif ($nxtState eq 'Q5')
        {
          tellUser('D1', "   closing: $tmpSpec");
          push(@segDefs, { tmpSpec => $tmpSpec, type => 'jpg' });
          close($imgFH)
            or confess("! $0: close error\n_ $tmpSpec\n_ $!\n_");

          $imgFH = undef();
          if ($c eq $FF)
            {
              $nxtState = 'Q2';
            }
          else
            {
              print($extraFH $c);
              $extraCnt++;
              $nxtState = 'Q1';
            }
        }
      elsif ($nxtState eq 'Q6')
        {
          print($imgFH $c);
          $nxtState = 'Q7' if ($c eq $FF);
        }
      elsif ($nxtState eq 'Q7')
        {
          print($imgFH $c);
          if ($c eq $D9) { $nxtState = 'Q3' }
          else           { $nxtState = 'Q6' }
        }
      else
        {
          confess("invalid nxtState: '$nxtState'");
        }
    }

  #-------------------------------------+
  # Finish any open image file and make	|
  # sure we ended in correct state.	|
  #-------------------------------------+

  if (defined($imgFH))
    {
      tellUser('D1', "closing last image output: $tmpSpec");
      push(@segDefs, { tmpSpec => $tmpSpec, type => 'jpg' });
      close($imgFH)
        or confess("! $0: close error\n_ $tmpSpec\n_ $!\n_");
    }

  confess("! $0: input file may be truncated or damaged\n")
    if ($nxtState !~ m/^(Q1|Q5)$/);

  #-------------------------------------+
  # Finish up the binary data output.	|
  #-------------------------------------+

  close($extraFH);
  tellUser('D3', "non-image bytes seen: $extraCnt");
  if ($opt{extraMode} and $extraCnt > 0)
    {
      push(@segDefs, { tmpSpec => $extraSpec, type => 'bin' });
      tellUser('D1', "non-image data saved: $tmpSpec");
    }

  #-------------------------------------+
  # Reset cursor in input file, report	|
  # the files we created.		|
  #-------------------------------------+

  seek($fh, 0, SEEK_SET) or tellUser('F', 'file read error', $fSpec, $!);
  return(@segDefs);
}

#------------------------------------------------------------------------------

sub parseStackedJPEG ( $ $ )

#      Abstract: Attempts to parse stacked JPEG image file.
#
#    Parameters: $fh      -- an open file handle in raw read mode.
#                $fSpec   -- the filespec of the source file
#
#       Returns: $fileCnt -- total number of output files created
#
#  Precondition: $fSpec is the file path and name for the file
#		 attached to $fh; $fh itself is an open file handle in
#		 raw mode and ready for read operations starting at
#		 the beginning of the file.  Global %opt is fully
#		 initialized.
#
# Postcondition: If there are no parsing errors, one or more output
#		 files are created from our input.  Our default mode
#		 is to not overwrite existing files.  In fact if
#		 expected output files already exist, we will output
#		 nothing and issue a warning.  However, if the global
#		 $opt{clobberMode} is true than any existing files
#		 with the same name are overwritten without comment.
#
#		 If the global $opt{allMode} is true than sequential
#		 file naming is used for all segments.  A warning is
#		 issued if we find the next logical filename in the
#		 sequence exists beyond the last file we have written.

{
  my($fh, $fSpec) = @_;
  assert((not isMissing($fSpec)), 'required parameter $fSpec is missing');
  assert((not isMissing($fh)),    'required parameter $fh is missing');

  #-------------------------------------+
  # Determine our parsing mode.		|
  #-------------------------------------+

  my $type;
  if    ($opt{allMode})       { $type = 'ALL'                        }
  elsif ($fSpec =~ m/\.jpg/i) { $type = 'JPG'                        }
  elsif ($fSpec =~ m/\.mpo/i) { $type = 'MPO'                        }
  else                        { assert(0, 'file type error', $fSpec) }

  #-------------------------------------+
  # Parse image, verify segment count	|
  # by type and mode.			|
  #-------------------------------------+

  seek($fh, 0, SEEK_SET) or tellUser('F', "file rewind error", $!);
  my @segments = FSM($fh, $fSpec, $opt{outputDir});
  my $segCnt = scalar(@segments);
  my $imgCnt = 0;
  my $binCnt = 0;

  if ($segCnt == 0)
    {
      tellUser('W', "empty input file?", $fSpec);
      return(0);                                                # CASE 0: empty
    }

  #-------------------------------------+
  # Count files created by type.  Don't	|
  # forget that the 'extra' bin file	|
  # will only be there by user request.	|
  #-------------------------------------+

  foreach my $seg (@segments)
    {
      my $type = $seg->{type};
      if    ($type eq 'jpg')  { $imgCnt++                               }
      elsif ($type eq 'bin')  { $binCnt++                               }
      else                    { assert(0, "unexpected keyword '$type'") }
    }

  tellUser('D4', "image files: $imgCnt", "extra files: $binCnt");

  assert(($segCnt > 0),  "no output files extracted");
  assert(($binCnt == 0), "unexpected binary 'extra' file", Dumper(@segments))
    if (not $opt{extraMode});

  if ($imgCnt < 2)
    {
      my $msg;
      if    ($imgCnt == 1) { $msg = "only one image found in file"     }
      elsif ($binCnt == 1) { $msg = "no JPEG images found in file"     }
      else                 { assert(0, "$imgCnt + $binCnt != $segCnt") }

      foreach my $seg (@segments)
        {
          my $tmpSpec = $seg->{tmpSpec};
          tellUser('D3', "cleanup $tmpSpec");
          unlink($tmpSpec)
            or tellUser('F', "error cleaning up temp file", $tmpSpec, $!);
        }

      tellUser('W', $msg, $fSpec);
      return(0);                                    # CASE 1: solo output file
    }

  #-------------------------------------+
  # Determine files to be saved based	|
  # on mode option, or type, or count.	|
  #-------------------------------------+

  my $leftIndex;
  my $rghtIndex;
  my $outputNumbered;

  if (not $outputNumbered)
    {
      if ($type eq 'ALL')
        {
          $outputNumbered = 1;
        }
      elsif ($type eq 'JPG')
        {
          if ($imgCnt == 4)
            {
              $leftIndex = 0;
              $rghtIndex = 2;
            }
          else
            {
              $outputNumbered = 1;
              tellUser(
                        'W',
                        "cannot assume input in LIF format",
                        $fSpec,
                        "created $imgCnt sequentially numbered image files"
                      );
            }
        }
      elsif ($type eq 'MPO')
        {
          if ($imgCnt == 2)
            {
              $leftIndex = 0;
              $rghtIndex = 1;
            }
          else
            {
              $outputNumbered = 1;
              tellUser(
                        'W',
                        "cannot assume input in LIF format",
                        $fSpec,
                        "created $imgCnt sequentially numbered image files"
                      );
            }
        }
      else
        {
          assert(0, "unexpected type: '$type'");
        }
    }

  #-------------------------------------+
  # Build rename/kill job list.		|
  #-------------------------------------+

  my $baseName = (File::Spec->splitpath($fSpec))[2];  # (volume, dirs, file)
  my $saveAs   = catfile($opt{outputDir}, $baseName);
  assert((not isMissing($saveAs)), "input filename parse error");
  $saveAs =~ s/$EXPECT_FILE_TYPE_RE//;

  my @jobQueue = ();
  if ($outputNumbered)
    {
      my $digits = length(scalar(@segments));
      my $FMT    = "%s_%0${digits}i-of-%0${digits}i.%s";
      for (my $i = 0; $i <= $#segments; $i++)
        {
          my $tmpSpec = $segments[$i]->{tmpSpec};
          my $fType   = $segments[$i]->{type};
          push(
                @jobQueue,
                [
                  'rename',
                  $tmpSpec,
                  sprintf($FMT, $saveAs, $i+1, scalar(@segments), $fType)
                ]
              );
        }
    }
  else
    {
      my $FMT = "%s_%s.%s";
      for (my $i = 0; $i <=$#segments; $i++)
        {
          my $tmpSpec = $segments[$i]->{tmpSpec};
          my $fType   = $segments[$i]->{type};
          my $suffix;
          if    ($i == $leftIndex) { $suffix = 'L' }
          elsif ($i == $rghtIndex) { $suffix = 'R' }
          else                     { $suffix = 0   }

          if ($fType eq 'bin')
            {
              push(@jobQueue,['rename',$tmpSpec,
                               sprintf($FMT, $saveAs, 'extra', $fType)
                            ]
                  );
            }
          elsif (not $suffix)
            {
              push(@jobQueue,['purge',$tmpSpec]);
            }
          else
            {
              push(@jobQueue,['rename',$tmpSpec,
                               sprintf($FMT, $saveAs, $suffix, $fType)
                            ]
                  );
            }
        }
    }

  #-------------------------------------+
  # Run the job list to rename/clobber	|
  # our final file set.			|
  #-------------------------------------+

  my $fileCnt = 0;
  tellUser('D6', split(/\n/, Dumper(\@jobQueue)));
  foreach my $job (@jobQueue)
    {
      my($action, $old, $new) = @{$job};
      if ($action eq 'purge')
        {
          if (unlink($old))
               { tellUser('D4', "deleted temp file: $old")           }
          else { tellUser('W', 'error removing temp file', $old, $!) }
        }
      elsif ($action eq 'rename')
        {
          if (not $opt{clobberMode} and -e $new)
            {
              tellUser('W', 'output file already exists', $new, 'skipped');
              if (unlink($old)) { tellUser('D1', "temp file cleanup: $old") }
              else              { tellUser('W',  "cleanup error", $old, $!) }
              next;
            }

          if (rename($old, $new))
               { tellUser('D4', "rename temp file", $old, $new); $fileCnt++ }
          else { tellUser('W', 'error renaming temp file', $old, $new, $!)  }
        }
      else
        {
          assert(0, "unexpected keyword '$action'");
        }
    }

  return($fileCnt);
}

#==============================================================================
#  Main Line  =================================================================
#==============================================================================

processOptions();
my @workList = processParams();

foreach my $fSpec (@workList)
  {
    tellUser('I', "Reading: $fSpec");
    open(my $source, '<:raw', $fSpec)
      or tellUser('F', 'error opening file in raw mode', $fSpec, $!);

    if (not $opt{allMode} and not isJPEG($fSpec, $source))
      {
        tellUser('W', "does not look like JPEG format", $fSpec, "skipped");
        next;
      }

    my $fileCnt = parseStackedJPEG($source, $fSpec);
    close($source);

    if ($opt{verboseMode})      { tellUser('I', " Output: $fileCnt files") }
    elsif (not $opt{quietMode}) { print("$fSpec ($fileCnt files)\n")       }
  }

__END__

#==============================================================================
#  POD  =======================================================================
#==============================================================================

=head1 NAME

mij-splitter -- split one Multi-Image JPEG file into individual JPEG files

=head1 SYNOPSIS

B<mij-splitter> [options] I<file1.jpg> I<...>

=head1 DESCRIPTION

By default this utility extracts the left and right stereo pair images
from either a Leia Image File (LIF) or Multi Picture Object (MPO)
file.  Schematically a LIF file, and the extracted L/R image pair,
looks like this:

     my-lif-image.jpg                my-lif-image_L.jpg
   +--------------------+          +--------------------+
   |                    |          |                    |
   |  Left JPEG Image   | -------> |  Left JPEG Image   |
   |                    |          |                    |
   |--------------------|          +--------------------+
   | short binary block |
   |--------------------|
   |                    |
   |  Left Depth Map    |
   |                    |
   |--------------------|
   | short binary block |            my-lif-image_R.jpg
   |--------------------|          +--------------------+
   |                    |          |                    |
   |  Right JPEG Image  | -------> | Right JPEG Image   |
   |                    |          |                    |
   |--------------------|          +--------------------+
   | short binary block |
   |--------------------|
   |                    |
   |  Right Depth Map   |
   |                    |
   |--------------------|
   | short text block   |
   +--------------------+

An MPO file has a similar structure only it may contain any number of
JPEG images in sequence.  However, the most common use for the MPO
format is for containing the left/right image pairs of a stereoscopic
image produced by a digital 3D camera.  As such this utility will
assume any MPO inputs have exactly two images and will emit a warning
if that is not the case.

=head2 Usage Notes

A preflight check is done on all command line arguments before
processing begins.  These checks include:

=over 2

=item -

Confirm all specified input files exist.

=item -

Disallow non-file specifications like directory-only paths.

=item -

All files have expected C<.jpg> or C<.mpo> extension.  Use C<-all>
option to override this restriction.

=item -

Do not process file if it does not begin with the expected
'start-of-image' (SOI) marker of a normal JPEG image.  Use C<-all>
option to override this restriction.

=item -

Reject filenames ending with C<_L> or C<_R> which look like our own
output.  Use C<-all> option to override this restriction.

=item -

Reject very large input files (over 150 megabytes).  Use -force to
override this restriction.

=back

=head1 OPTIONS

All option names may be abbreviated down to the first letter.

=over 12

=item B<-all>

Extract all detected JPEG images without reference to expected
left/right pairs or a specific number of images.  Each image is
extracted and named using sequential "nn-of-nn" numbering.  This
option also ignores the input file extension, and also allows input
files that do not immediately begin with a JPEG signature.

=item B<-extra>

Use this option to save non-JPEG image data from the original file to
a C<*_extra.bin> file.  Normally any non-JPEG information is quietly
ignored and discarded.  If the L<hexdump(1)> utility is available on
your system, using the C<-C> option is a convenient tool for examining
the contents of this file.  The original location of the extracted
images will be illustrated with C<E<lt>IMGnE<gt>> strings, as
illustrated here:

 $ hexdump -C mypic_extra.bin
 00000000  3c 49 4d ... 00 00  |<IMG0>..........|
 00000010  00 04 00 ... 00 00  |................|
 00000020  00 01 00 ... 31 3e  |....BA...-<IMG1>|
 00000030  00 0f 42 ... 00 0f  |..BB.i .<IMG2>..|
 00000040  42 43 00 ... 00 07  |BC...v<IMG3>....|
 00000050  00 00 01 ... 6e 63  |....{"convergenc|
 00000060  65 22 3a ... 38 35  |e":-0.0112278685|
 00000070  2c 22 64 ... 72 63  |,"disparitySourc|
 00000080  65 22 3a ... 52 45  |e":"NEURAL_STERE|
 00000090  4f 22 2c ... 22 69  |O","gain":1.0,"i|
    :          :           :          :
    :          :           :          :
 00000160  6f 63 61 ... 7d 00  |ocation":0.0}]}.|
 00000170  7f bf bd ...        |.....|
 00000175
 $

=item B<-force>

Use this option to force reading very large files.

=item B<-verbose>

Displays additional progress information to STDERR.

=item B<-quiet>

Suppresses non-fatal warning messages and default progress messages to
STDERR.

=item B<-debug=n>

Turn on debugging messages to STDERR.  'n' is an integer from 1-9
indicating the level of detail with 1 indicating minimal, and 9 the
maximum.  However there may not be 8 distinct message levels actually
implemented.  A setting of -d=0 turns off debugging messages.  If
no integer value is specified, the default is level 1.

=item B<-help>

Display command synopsis and options to STDOUT and exit.

=item B<-manpage>

Display to STDOUT entire man page and exit.

=back

Note that -verbose and -quiet are mutually exclusive.

=head1 EXAMPLES

=over 3

=item 1.

Given the command:

    $ mij-splitter this.jpg that.jpg

If the input files are valid LIF format, four output files are generated:

    this_L.jpg
    this_R.jpg
    that_L.jpg
    that_R.jpg

=item 2.

Split all MPO files in current directory and save them in "Pairs"
subdirectory.  If the subdirectory does not exist, create it.

    $ mij-splitter -o=Pairs *.mpo

=back

=head1 SEE ALSO

=head2 Leia Image Format (H4V)

  https://docs.leialoft.com/developer/android-media-sdk/supported-media

  https://h4vapp.com/

=head2 MPO Specification and Utilities

  https://www.cipa.jp/std/documents/e/DC-X007-KEY_E.pdf

  https://github.com/tribut/mposplit

  https://github.com/ssmehta/mpo2stereo

  http://stereo.jpn.org/eng/stphmkr/help/file_35.htm

=head1 BUGS & LIMITATIONS

We use a very naive understanding of how a LIF or MPO file is
formatted.  The assumption is that each JPEG segment has a specific
two-byte character pair identifying the start and end of each image.
In particular we are blind to the "MP index IFD" metadata which
catalogs and points to each of images within an MPO file.  On the plus
side, by using the C<-all> option, this utility could be used to
extract JPEG images from just about any file that has two or more JPEG
images that have been simply concatenated together.

Any thumbnail images embedded within a JPEG segment are not extracted
to their own file, but remain encoded within the parent image.

=head1 FUTURES

=over 5

=item - No new features planned at this time.  Suggestions welcomed.

=back

=head1 AUTHOR

Bill.Costa@alumni.unh.edu

=cut

#=[ EOF: mij-splitter ]==
