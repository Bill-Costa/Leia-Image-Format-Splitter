#!/usr/bin/env perl
# -*- cperl -*-
#
#         File:	lif-splitter
#      Summary:	Splits a Leia Image Format (LIF) 3D image file into L/R pair.
#        Usage:	lif-splitter file1 [...]
#	  Help:	lif-splitter -h
#     Man Page:	lif-splitter -m
#       Author:	Bill.Costa@alumni.unh.edu
# Project Page:	https://github.com/Bill-Costa/Leia-Image-Format-Splitter
#
#=============================================================================

use warnings;			# Warning me when I do something stupid.
use strict;			# Keep things squeaky clean.
use Data::Dumper;		# Easy data structure debugging.
use Getopt::Long;		# Parse our command line please.
use File::Basename;		# For parsing file names.
use Pod::Usage;			# Easy usage text, help, and man page.
#use Text::Abbrev;		# Allow keyword abbreviation.
use Fcntl qw(SEEK_SET);         # Used in seek() function for moving cursor.
no autovivification;		# Allow hash key testing without auto creation.
				#--[ Global Vars ]-----------------------------
my $ownName = (fileparse	# Get our own name, that is, how we were
                (		#   invoked, minus pathname and suffix.
		  $0,
		  qr/\.[^.]*/
		)
              )[0];

my $discardBuf    = undef();	# If defined, non-image binary data
my %opt           = ();		# Command line options.
$opt{clobberMode} = 0;		# -clobber : overwrite existing file
$opt{forceMode}   = 0;          # -force   : ignore file errors
$opt{extraMode}   = 0;		# -extra   : non-image data to discard file
$opt{allMode}     = 0;		# -all     : export all JPGs with ord naming
$opt{whatIfMode}  = 0;		# -whatif  : echo action but change nothing
$opt{quietMode}   = 0;		# -quiet   : suppress warning messages
$opt{verboseMode} = 0;		# -verbose : show progress
$opt{debugMode}   = undef();	# -debug   : undef or 0-9
#$opt{saveasMode}  = 'pairs';	# -saveas  : one of 'pairs', 'jps', 'sbs'

my $FF = chr(0xFF);
my $D8 = chr(0xD8);
my $D9 = chr(0xD9);
my $MAX_SIZE = (4 * 8000 * 5000); # 4 uncompressed 8K images in one file.

#==============================================================================
#  Subroutines  ===============================================================
#==============================================================================

sub isMissing ( $ )

#      Abstract: Returns true if scalar is undefined, empty, or blank string.
#
#    Parameters: $str -- simple char string or undefined
#
#       Returns: $bool -- true if there is no useful value
#
#  Precondition: None.
#
# Postcondition: Returns boolean value with no side effects.

{
  if (not defined($_[0]) or $_[0] =~ m/^\s*$/s) { return(1) }
  else                                          { return(0) }
}

#------------------------------------------------------------------------------

sub trimStr ( $ )

#      Abstract: Remove leading and trailing whitespace.
#
#    Parameters: $str -- simple char string (no embedded carriage control)
#
#       Returns: $new -- the trimmed string value
#
#  Precondition: None.
#
# Postcondition: $str is returned with  leading and trailing blanks
#		 removed.  If the string is all whitespace, or undefined,
#		 we return an empty string.

{
  my $str = shift(@_);
  return('') if (not defined($str));
  $str =~ s/^\s+|\s+$//g;
  return($str);
}

#------------------------------------------------------------------------------

sub assert ( $ @ )

#      Abstract: Throws fatal error if $boolExp is not true.
#
#    Parameters: $boolExp   -- a Perl expression to eval as Perlish T/F.
#                $msgStr(s) -- one or more message strings to display on exit.
#
#       Returns: 1 (true) assuming we do not thrown a fatal error
#
#  Precondition: None.
#
# Postcondition: If the expression evaluates to a Perlish false value,
#		 we throw a 'logic error' exception and display any
#		 message strings provided and a stack trace.

{
  use Carp;			# Gives us confess() for stack backtrace,
  $Carp::CarpLevel = 1;	# but don't report the assert() in backtrace.
  my $boolExp = shift(@_);
  $_[0] = '(no message)' if (not defined($_[0]));
  if (not $boolExp)
    {
      $! = 255;
      confess(
	       "! $ownName: internal logic error\n",
	       "_ ", join("\n_ ", @_), "\n_"
	     );
    }

  return(1);
}

#------------------------------------------------------------------------------

sub tellUser ( $ @ )

#      Abstract: Conditionally print diagnostic to STDERR.
#
#    Parameters: $msgLevel  - message type indicator (see below)
#		 $msgStr(s) - one or more message strings to display
#
#       Returns: 1 (true) assuming we don't throw an exception
#
#  Precondition: msgLevel is a single letter, one of [IWU], or the
#		 letter 'D' or 'F' and a single digit (i.e. 'D1',
#		 'F7', etc.).  The remaining parameters, of which
#		 there should be at least one, are treated as message
#		 strings.  The globals $ownName and %flag variables
#		 must be defined.
#
# Postcondition: Print formatted messages to STDERR.  The following
#		 actions are taken depending upon the initial letter
#		 code:
#
#		  'W'  - print a warning unless -quiet is set.
#
#		  'U'  - print fatal error message, usage info, and abort.
#
#		  'I'  - print an info msg if -verbose is set.
#
#                 'T'  - print 'WOULD HAVE:' message if -whatif is set.
#
#		  'Fn' - print a fatal error message and abort
#		         program, where 'n' is an integer > 2, the
#		         exit value.  If not specified, the default
#		         exit value is 3.
#
#		  'Dn' - print debug message if 'n' is less than or
#			 equal to the current debug level value.
#			 (Use 'D0' to always print message, regardless
#			 of user selected debugging level.)

{
  my($level) = uc(shift(@_));

  assert(defined($level), 'required parameter not defined');
  assert(($level =~ m/^[DIWUF]/), "did not expect '$level'");
  assert(scalar(@_) > 0, "no message supplied");

  if ($level =~ m/^D(\d)$/)
    {
      print(STDERR "DDT: ", join("\n   : ", @_), "\n")
	if ($1 <= $opt{debugMode});
    }
  elsif ($level eq 'I')
    {
      print(STDERR "(i) ", join("\n    ", @_), "\n")
	if ($opt{verboseMode});
    }
  elsif ($level eq 'W')
    {
      warn("? $ownName: ",join("\n_ ", @_),"\n")
        if (not $opt{quietMode});
    }
  elsif ($level eq 'T')
    {
      warn("WOULD-HAVE: ", join("\n          : ", @_),"\n")
        if ($opt{whatIfMode});
    }
  elsif ($level eq 'U')
    {
      my $msg = "? $ownName: " . join("\n_ ", @_);
      pod2usage(-verbose => 0, -exitval => 3, -msg => $msg);
    }
  elsif ($level =~ m/^F([0-9]?[0-9]*)$/)
    {
      if ($1 eq ''  or ($1 <= 3)) { $! = 3  }
      else                        { $! = $1 }

      die("! $ownName: ", join("\n_ ", @_), "\n");
    }
  else
    {
      assert(0, "unreachable code reached; \$level = '$level'");
    }

  return(1);
}

#------------------------------------------------------------------------------

sub processOptions ( )

#      Abstract: Validate and remove options from @ARGV.
#
#    Parameters: None.
#
#       Returns: 1 (true) assuming we don't thrown an exception
#
#  Precondition: We get first crack at the contents of @ARGV.
#
# Postcondition: All flags are found on the command line, assigned to
#		 global variables, and removed from the @ARGV array,
#		 leaving only parameters (if any).

{
  my $helpMode;
  my $manMode;
  # my @SAVE_KW       = qw(pairs jps sbs); # -save option keywords
  # my %SAVE_KW_MATCH = abbrev(@SAVE_KW);  # Recognized abbreviations for all.

  GetOptions(
              'e|extra'    => \$opt{extraMode},
              'f|force'    => \$opt{forceMode},
              'w|whatif'   => \$opt{whatIfMode},
	      'd|debug:i'  => \$opt{debugMode},
              'q|quiet!'   => \$opt{quietMode},
              'v|verbose!' => \$opt{verboseMode},
           #  's|saveas=s' => \$opt{saveasMode},

              'h|help'     => \$helpMode,
              'm|manpage'  => \$manMode,
            )
    or pod2usage(-verbose => 0, -exitval => 2);

  #---------------------------------------------+
  # Handle requests for help and exit here.	|
  #---------------------------------------------+

  pod2usage(-noperldoc => 1, -verbose => 1) if ($helpMode);
  pod2usage(                 -verbose => 2) if ($manMode);

  #---------------------------------------------+
  # Check for conflicting options. Exit now	|
  # if we find any.				|
  #---------------------------------------------+

  pod2usage("verbose and quiet are mutually exclusive")
    if ($opt{verboseMode} and $opt{quietMode});

  pod2usage("quiet and debug are mutually exclusive")
    if ($opt{quietMode} and $opt{debugMode});

  #---------------------------------------------+
  # Get/validate our save mode.			|
  #---------------------------------------------+

  # assert(defined($opt{saveasMode}), "\$opt{saveasMode} not defined");
  # $opt{saveasMode} = lc($opt{saveasMode});

  # if (defined($SAVE_KW_MATCH{$opt{saveasMode}}))
  #   {
  #     # not ready to solve this yet because external software
  #     # is needed.
  #   }
  # else
  #   {
  #     tellUser('U', "unrecognized -saveas keyword: '$opt{saveMode}'",
  #                   "expect one of: " . join('|', @SAVE_KW),
  #                   "use -manpage option for more information"
  #             );

  #   }

  #---------------------------------------------+
  # Get the debug mode and show our option	|
  # settings if level 2 or higher.		|
  #---------------------------------------------+

  if (not defined($opt{debugMode})) { $opt{debugMode} = 0 }
  elsif ($opt{debugMode} == 0)      { $opt{debugMode} = 1 }

  tellUser('U', "-debug requires a value from 1-9, not '$opt{debugMode}'")
    if ($opt{debugMode} < 0 or $opt{debugMode} > 9);

  if ($opt{debugMode} >= 2)
    {
      my @buff = ();
      foreach my $key (sort(keys(%opt)))
        {
          my $label = $key;
          $label =~ s/Mode$//;
          $label = '-' . $label;

          my $val = $opt{$key};
          if (not defined($val))   { $val = 'NULL'   }
          elsif ($val !~ m/^\d+$/) { $val = "'$val'" }

          push(@buff, sprintf("%10s = %s", $label, $val));
        }

      tellUser('D2', @buff);
    }

  return(1);
}

#------------------------------------------------------------------------------

sub processParams ( )

#      Abstract: Validate and remove parameters from @ARGV.
#
#    Parameters: None.
#
#       Returns: @files -- an array of one or more filespecs
#
#  Precondition: Local processOptions() is called first.
#
# Postcondition: Removes all remaining parameters from ARGV.  All
#		 files identified in @files exist at the time we
#		 checked and are not directories, or we return a usage
#		 error and throw an exception.

{
  tellUser('U', "one or more JPG filenames expected") if (scalar(@ARGV) < 1);

  my @files = ();
  my $errCnt = 0;
  my $argNum = 1;
  my $argCnt = scalar(@ARGV);

  foreach my $nxt (@ARGV)
    {
      tellUser('D1', "ARG $argNum of $argCnt: $nxt");
      $argNum++;
      next if (isMissing($nxt));
      tellUser("expect JPG image, not a directory", $nxt) if (-d $nxt);
      if (not -e $nxt)
        {
          tellUser('W', "file lookup error", $nxt, $!);
          $errCnt++;
          next;
        }

      push(@files, $nxt);
    }

  tellUser('U', "no input files found") if (scalar(@files) < 1);
  tellUser('U', "halting execution; no files processed")
    if ($errCnt > 0 and not $opt{forceMode});

  return(@files);
}

#------------------------------------------------------------------------------

sub isJPEG ( $ $ )

#      Abstract: Returns true if file starts with JPEG image marker.
#
#    Parameters: $fSpec -- the filespec of the source file
#		 $fh -- an open filehandle in raw read mode.
#
#       Returns: $bool -- explicitly 0 or 1
#
#  Precondition: $fSpec is the file path and name for the file
#		 attached to $fh; $fh itself is an open filehandle in
#		 raw mode and ready for read operations.
#
# Postcondition: The filehandle is returned with the cursor set to the
#		 beginning of the file, without regard to its original
#		 position.  A fatal error is thrown if any file
#		 handling error occurs.
#
#         Notes: We make sure we are at the start of the file, sample
#		 the first two characters, rewind back to the start of
#		 the file, return the results of our lookahead.

{
  my($fSpec, $fh) = @_;
  assert((not isMissing($fSpec)), 'required parameter $fSpec is missing');
  assert((not isMissing($fh)),    'required parameter $fh is missing');

  seek($fh, 0, SEEK_SET) or tellUser('F', 'file read error', $fSpec, $!);
  my $charCnt = read($fh, my $str, 2);
  tellUser('F', "file read error", $fSpec, $!) if (not defined($charCnt));
  seek($fh, 0, SEEK_SET) or tellUser('F', "file rewind error", $!);
  return(0) if ($charCnt < 2);
  return(0) if (substr($str,0,1) ne $FF and substr($str,1,1) ne $D8);
  return(1);
}

#------------------------------------------------------------------------------

sub parseLIF ( $ $ )

#      Abstract: Attempts to parse a LIF format JPEG file.
#
#    Parameters: $fSpec -- the filespec of the source file
#		 $fh -- an open filehandle in raw read mode.
#
#       Returns: $totalBytes -- total number of bytes read from $fh.
#
#  Precondition: $fSpec is the file path and name for the file
#		 attached to $fh; $fh itself is an open filehandle in
#		 raw mode and ready for read operations starting at
#		 the beginning of the file.  Global %opt is fully
#		 initialized.
#
# Postcondition: If there are no parsing errors, one or more output
#		 files are created from our input.  Our default mode
#		 is to not overwrite existing files.  In fact if
#		 either the left or right image files exist, we will
#		 output nothing and issue a warning.  In default mode
#		 we also warn if we did not see exactly four JPEG
#		 segments as expected in a LIF file.
#
#		 If the global $opt{clobberMode} is true than any
#		 existing files with the same name are overwritten
#		 without comment.
#
#		 If the global $opt{allMode} is true than sequential
#		 file naming is used for all segments.  A warning is
#		 issued if we find the next logical filename in the
#		 sequence exists beyond the last file we have written.

{
  my($fSpec, $fh) = @_;
  assert((not isMissing($fSpec)), 'required parameter $fSpec is missing');
  assert((not isMissing($fh)),    'required parameter $fh is missing');
  seek($fh, 0, SEEK_SET) or tellUser('F', "file rewind error", $!);

  my $segCnt     = 0;
  my $totalBytes = 0;
  while (not eof($fh))
    {
      my $charCnt = read($fh, my $str, 1);
      tellUser('F', "file read error", $fSpec, $!) if (not defined($charCnt));
      last if ($charCnt == 0);
      $totalBytes++;
    }

  return($totalBytes);
}

#==============================================================================
#  Main Line  =================================================================
#==============================================================================

processOptions();
my @workList = processParams();

foreach my $fSpec (@workList)
  {
    open(my $source, '<:raw', $fSpec)
      or die("! $0: error opening file in raw mode\n_ $fSpec\n_ $!\n");

    if (not $opt{allMode} and not isJPEG($fSpec, $source))
      {
        tellUser('W', "does not look like JPEG format", $fSpec, "skipped");
        next;
      }

    my $totalBytes = parseLIF($fSpec, $source);
    close($source);

    print("---> $fSpec: $totalBytes\n");
    close($source);
  }

__END__

#==============================================================================
#  POD  =======================================================================
#==============================================================================

=head1 NAME

lif-splitter -- split Leia Image Format 3D image file into L/R stereo pairs

=head1 SYNOPSIS

B<lif-splitter> [options] I<file1.jpg> I<...>

=head1 DESCRIPTION

This utility extracts the left and right stereo pair images from a
Leia Image File (LIF) 3D image file.  By default the corresponding
left and right depth maps are not saved.  Schematically a LIF file,
and the extracted L/R image pair, looks like this:

     my-lif-image.jpg                my-lif-image_L.jpg
   +--------------------+          +--------------------+
   |                    |          |                    |
   |  Left JPEG Image   | -------> |  Left JPEG Image   |
   |                    |          |                    |
   |--------------------|          +--------------------+
   | short binary block |
   |--------------------|
   |                    |
   |  Left Depth Map    |
   |                    |
   |--------------------|
   | short binary block |            my-lif-image_R.jpg
   |--------------------|          +--------------------+
   |                    |          |                    |
   |  Right JPEG Image  | -------> | Right JPEG Image   |
   |                    |          |                    |
   |--------------------|          +--------------------+
   | short binary block |
   |--------------------|
   |                    |
   |  Right Depth Map   |
   |                    |
   |--------------------|
   | short text block   |
   +--------------------+

=head1 OPTIONS

All option names may be abbreviated down to the first letter.

=over 12

=item B<-all>

Blah blah blah...

=item B<-verbose>

Blah blah blah...

=item B<-quiet>

Suppresses non-fatal warning messages and default progress messages to STDERR.

=item B<-debug=n>

Turn on debugging messages to STDERR.  'n' is an integer from 1-9
indicating the level of detail with 1 indicating minimal, and 9 the
maximum.  However there may not be 8 distinct message levels actually
implemented.  A setting of -d=0 turns off debugging messages.  If
no integer value is specified, the default is level 1.

=item B<-help>

Display command synopsis and options to STDOUT and exit.

=item B<-manpage>

Display to STDOUT entire man page and exit.

=back

Note that -verbose and -quiet are mutually exclusive.

=head1 EXAMPLES

Given the command:

    $ lif-splitter this.jpg that.jpg

If the input files are valid LIF format, four output files are generated:

    this_L.jpg
    this_R.jpg
    that_L.jpg
    that_R.jpg

=head1 ENVIRONMENT

The following environment variables affect the execution of B<lif-splitter>:

=over 20

=item PIXDATES_FOOBAR

This is something that you can set.  Xyaoda akjdk akauq a akjasua
weafa askduaywed.

=item PIXDATES_FLIPPER

Xyaoda akjdk akauq.  This is something that you can set.  Xyaoda akjdk
akauq a akjasua weafa askduaywed. Xyaoda akjdk akauq.

=item FOOBAR_FIXOPAK_AKDK

Xyaoda akjdk akauq a akjasua weafa askduaywed flilak askusd lasdj.
Xyaoda akjdk akauq a akjasua. Xyaoda akjdk akauq a akjasua weafa
askduaywed.

=back

=head1 SEE ALSO

something(1)

=head1 BUGS & LIMITATIONS

We have a naive understanding of how a LIF file is formatted beyond
the fact that each JPEG segment has a specific two-byte character pair
identifying the start and end of each image.  On the plus side, by
using the C<-all> option, this utility could be used to extract JPEG
images from just about any file that has two or more JPEG images that
have been simply concatenated together.

=head1 FUTURES

=over 5

=item - No new features planned at this time.  Suggestions welcomed.

=back

=head1 AUTHOR

Bill.Costa@alumni.unh.edu

=cut

#=[ EOF: lif-splitter ]==
